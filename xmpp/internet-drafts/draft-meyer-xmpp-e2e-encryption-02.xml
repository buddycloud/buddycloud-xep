<?xml version="1.0"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?rfc toc="yes"?>
<?rfc tocdepth="4"?>
<?rfc symrefs="yes"?>
<?rfc compact="yes"?>
<?rfc strict="yes"?>
<rfc category="std" docName="draft-meyer-xmpp-e2e-encryption-02" ipr="trust200902">
  
  <front>
    <title abbrev='XTLS'>XTLS: End-to-End Encryption for the Extensible Messaging and Presence Protocol (XMPP) Using Transport Layer Security (TLS)</title>
    <author initials="D." surname="Meyer" fullname="Dirk Meyer">
      <organization>Universitaet Bremen TZI</organization>
      <address>
        <email>dmeyer@tzi.de</email>
      </address>
    </author>
    <author initials="P." surname="Saint-Andre" fullname="Peter Saint-Andre">
      <organization>Cisco</organization>
      <address>
        <email>psaintan@cisco.com</email>
      </address>
    </author>
    <date day="29" month="June" year="2009"/>
    <area>Applications</area>
    <keyword>Extensible Messaging and Presence Protocol</keyword>
    <keyword>XMPP</keyword>
    <keyword>Jabber</keyword>
    <keyword>encryption</keyword>
    <abstract>
      <t>This document specifies "XTLS", a protocol for end-to-end encryption of Extensible Messaging and Presence Protocol (XMPP) traffic.  XTLS is an application-level usage of Transport Layer Security (TLS) that is set up using the XMPP Jingle extension for session negotiation and transported using any streaming transport as the data delivery mechanism.  Thus XTLS treats the end-to-end exchange of XML stanzas as a virtual transport and uses TLS to secure that transport, enabling XMPP entities to communicate in a way that is designed to ensure the confidentiality and integrity XML stanzas.  The protocol can be used for secure end-to-end messaging as well as other XMPP applications, such as file transfer.</t>
    </abstract>
  </front>

  <middle>
    <section title="Introduction" anchor="intro">
      <t>End-to-end encryption of traffic sent over the Extensible Messaging and Presence Protocol (XMPP) is a desirable goal.  Requirements and a threat analysis for XMPP encryption are provided in <xref target='E2E-REQ'/>.  This document explores the possibility of using the Transport Layer Security <xref target='TLS'/> to meet those requirements.</t>
      <t>TLS is the most widely implemented protocol for securing network traffic.  In addition to applications in the email infrastructure, the World Wide Web <xref target='HTTP-TLS'/>, and datagram transport for multimedia session negotiation <xref target='DTLS'/>, TLS is used in XMPP to secure TCP connections from client to server and from server to server, as specified in <xref target='XMPP-CORE'/>.  Therefore TLS is already familiar to XMPP developers.</t>
      <t>This specification, called "XTLS", defines a method whereby any XMPP entity that supports the XMPP Jingle negotiation framework <xref target='JINGLE'/> can use TLS semantics for end-to-end encryption, whether the application data is sent over a streaming transport (like TCP) or a datagram transport (like UDP).  The basic use case is to tunnel XMPP stanzas between two IM users for end-to-end secure chat using end-to-end XML streams.  However, XTLS is not limited to encryption of one-to-one text chat, since it can be used between two XMPP clients for encryption of any XMPP payloads, between an XMPP client and a remote XMPP service (i.e., a service with which a client does not have a direct XML stream, such as a <xref target='MUC'/> chatroom), or between two remote XMPP services.  Furthermore, XTLS can be used for encrypted file transfer using <xref target='JINGLE-FILE'/>, for encrypted voice or video sessions using <xref target='JINGLE-RTP'/> and <xref target='DTLS-SRTP'/>, and other applications.</t>
      <t>Note: The following capitalized keywords are to be interpreted as described in <xref target="TERMS"/>: "MUST", "SHALL", "REQUIRED"; "MUST NOT", "SHALL NOT"; "SHOULD", "RECOMMENDED"; "SHOULD NOT", "NOT RECOMMENDED"; "MAY", "OPTIONAL".</t>
    </section>

    <section title='Approach' anchor='approach'>
      <t>In broad outline, XTLS takes the following approach to end-to-end encryption of XMPP traffic:</t>
      <t>
        <list style='numbers'>
          <t>We assume that all XMPP entities will have X.509 certificates; realistically these certificates are likely to be self-signed and automatically generated by an XMPP client, however certificates issued by known certification authorities are encouraged to overcome problems with self-signed certificates.</t>
          <t>We use the XMPP Jingle extensions as the negotiation framework (see <xref target='JINGLE'/>).</t>
          <t>We use the concept of Jingle security preconditions to ensure that the negotiated transport will be encrypted before used for sending application data.</t>
          <t>When an entity wishes to encrypt its communications with a second entity, it sends a Jingle session-initiate request that specifies the desired application type, a possible transport, and a TLS security precondition that includes the sender's X.509 fingerprint and optionally hints about the sender's supported TLS methods.</t>
          <t>If both parties support XTLS, the first data sent over the negotiated transport is TLS handshake data, not application data.  Once the TLS handshake has finished, the parties can then send application data over the now-encrypted transport (called an "XTLS tunnel").</t>
          <t>The simplest scenario is end-to-end encryption of traditional XMPP text chat using end-to-end XML streams as the application and in-band bytestreams <xref target='IBB'/> as the transport.</t>
          <t>If the parties have previously negotiated an XTLS tunnel, during the TLS negotiation each party simply needs to verify that the other party is presenting the same certificate as used in previous sessions.</t>
          <t>If the parties have not previously negotiated an XTLS tunnel, they need to bootstrap trust in their certificates; to do so, it is encouraged to use secure remote passwords rather than leap-of-faith.</t>
        </list>
      </t>
      <t>We expand on this approach in the following section.</t>
      <t>More complex scenarios are theoretically supported (e.g., encrypted file transfer using SOCKS5 bytestreams and encrypted voice chat using DTLS-SRTP) but have not yet been fully defined.</t>
      <t>XTLS theoretically can be used to establish a TLS-encrypted streaming transport or a DTLS-encrypted datagram transport, but integration with DTLS <xref target='DTLS'/> has not yet been prototyped so use with streaming transports is the more stable scenario.</t>
    </section>

    <section title='XTLS Protocol Flow' anchor='proto'>
      <t>The basic flow for an XTLS session is as follows, where traffic represented by single dashes (---) is sent over the XMPP signalling channel and traffic represented by double lines (===) is sent over the negotiated transport.</t>
      <figure>
        <artwork><![CDATA[
Initiator                   Responder
  |                            |
  |  session-initiate          |
  |  (with security info)      |
  |--------------------------->|
  |  ack                       |
  |<---------------------------|
  |  session-accept            |
  |<---------------------------|
  |  ack                       |
  |--------------------------->|
  |  open transport            |
  |<==========================>|
  |  TLS ClientHello           |
  |===========================>|
  |  TLS ServerHello, [...]    |
  |<===========================|
  |  TLS [...], Finished       |
  |===========================>|
  |  TLS [...], Finished       |
  |<===========================|
  |  application data          |
  |<==========================>|
  |  session-terminate         |
  |<---------------------------|
  |  ack                       |
  |--------------------------->|
  |                            |
        ]]></artwork>
      </figure>
      <t>To simplify the description we assume here that the parties already trust each other's certificates.  See discussion under <xref target='bootstrapping'/> for information about bootstrapping of certificate trust when the parties first negotiate the use of an XTLS tunnel.</t>
      <t>First the initiator sends a Jingle session-initiate request (here the simple case of an end-to-end text chat session using in-band bytestreams <xref target='IBB'/>).  This request includes a &lt;security/&gt; element that contains the fingerprint of the certificate that the initiator will use during the TLS negotiation and a list of TLS methods the initiator supports (here certificate-based authentication <xref target='X509'/> and TLS with Secure Remote Passwords <xref target='TLS-SRP'/>).  Note that this information is exchanged over the insecure server-based connection.  The purpose of the exchange is to gather information about which TLS method should be used in the TLS handshake, e.g. if a client cannot verify the fingerprint of the peer it MAY omit the X.509 method.  If both clients can verify the fingerprint of the other, it is likely that X.509 certificate-based authentication will succeed (unless the data is altered); if one client cannot verify the fingerprint the client MAY prompt the user for a password for TLS-SRP based authentication (see <xref target='bootstrapping'/> for details).</t>
      <figure>
        <artwork><![CDATA[
<iq from='romeo@montague.lit/orchard'
    id='xn28s7gk'
    to='juliet@capulet.lit/balcony'
    type='set'>
  <jingle xmlns='urn:xmpp:jingle:1'>
          action='session-initiate'
          initiator='romeo@montague.lit/orchard'
          sid='a73sjjvkla37jfea'>
    <content creator='initiator' name='xmlstream'>
      <description xmlns='urn:xmpp:jingle:apps:xmlstream:0'/>
      <transport xmlns='urn:xmpp:jingle:transports:ibb:0'
                 block-size='4096'
                 sid='ch3d9s71'/>
      <security xmlns='urn:xmpp:jingle:security:xtls:0'>
        <fingerprint algo='sha1'>RomeoX509CertSHA1Hash</fingerprint>
        <method name='x509'/>
        <method name='srp'/>
      </security>
    </content>
  </jingle>
</iq>
        ]]></artwork>
      </figure>
      <t>The responder immediately acknowledges receipt of the session-initiate by sending an IQ stanza of type "result" (not shown here).</t>
      <t>Depending on the application type, a user agent controlled by a human user might need to wait for the user to affirm a desire to proceed with the session before continuing.  When the user agent has received such affirmation (or if the user agent can automatically proceed for any reason, e.g.  because no human intervention is expected or because a human user has configured the user agent to automatically accept sessions with a given entity), it returns a Jingle session-accept message.  This message will typically contain the offered application type, transport method, and a &lt;security/&gt; element that includes the fingerprint of the responder's X.509 certificate as well as the responder's supported TLS methods.</t>
      <figure>
        <artwork><![CDATA[
<iq from='juliet@capulet.com/balcony'
    id='hf64hl'
    to='romeo@montague.net/orchard'
    type='set'>
  <jingle xmlns='urn:xmpp:jingle:1'>
          action='session-accept'
          initiator='romeo@montague.lit/orchard'
          sid='a73sjjvkla37jfea'>
    <content creator='initiator' name='xmlstream'>
      <description xmlns='urn:xmpp:jingle:apps:xmlstream:0'/>
      <transport xmlns='urn:xmpp:jingle:transports:ibb:0'
                 block-size='4096'
                 sid='ch3d9s71'/>
      <security xmlns='urn:xmpp:jingle:security:xtls:0'/>
        <fingerprint algo='sha1'>JulietX509CertSHA1Hash</fingerprint>
        <method name='x509'/>
        <method name='srp'/>
      </security>
    </content>
  </jingle>
</iq>
        ]]></artwork>
      </figure>
      <t>The following rules apply to the responder's handling of the session-initiate message:</t>
      <t>
        <list style='numbers'>
          <t>If the responder does not support XTLS it will silently ignore the &lt;security/&gt; element in the offer and therefore will return a session-accept message without a &lt;security/&gt; element.</t>
          <t>If the responder supports XTLS it MUST return a session-accept message that contains a &lt;security/&gt; element.</t>
          <t>If the responder thinks it will be able to verify the initiator's certificate, it MUST include the fingerprint for the responder's certificate in the &lt;security/&gt; element of the session-accept message.  This is the "happy path" and will occur when the parties have already verified each other's certificates.</t>
          <t>If the responder thinks it will not be able to verify the initiator's certificate, it MAY omit the fingerprint for the responder's certificate in the &lt;security/&gt; element of the session-accept message.  This indicates that certificate-based authentication is not possible.  In this case the responder SHOULD signal that it wishes to use some other authentication method, such as secure remote passwords (see discussion under <xref target='bootstrapping'/>).</t>
          <t>If the responding client cannot verify the initiator's certificate, it SHOULD ask the responding user if a password was exchanged between the parties that can be used for TLS-SRP.  If this is not the case, setting up a mutually-authenticated link will fail and the responder MAY terminate the session.  Alternatively it could send its own fingerprint knowing it cannot authenticate the initiator, in which case the responder has to trust that there is no man-in-the-middle (see discussion under <xref target='bootstrapping'/>).</t>
        </list>
      </t>
      <t>When the responder sends the session-accept message, the initiator acknowledges receipt by sending an IQ stanza of type "result" (not shown here).</t>
      <t>The following rules apply to the initiator's handling of the session-accept message:</t>
      <t>
        <list style='numbers'>
          <t>If the initiator receives a session-accept without a &lt;security/&gt; element, setting up a secure transport layer has failed.  The initiator MAY terminate the session at this point or instead proceed without securing the transport.  The client SHOULD ask the initiating user how to processed.  This depends on the Jingle application and the initiator's preferences: it makes no sense to use end-to-end XML streams without encryption, but the initiator might continue a file transfer without encryption.</t>
          <t>If the initiating client cannot verify the responder's certificate it SHOULD ask the initiating user if a password was exchanged between the parties that can be used for TLS-SRP.  If this is not the case, setting up a mutually-authenticated link will fail and the responder MAY terminate the session or proceed with leap-of-faith (see discussion under <xref target='bootstrapping'/>).</t>
        </list>
      </t>
      <t>The initiator can now determine if X.509 certificate-based authentication will work or if TLS-SRP will be used.  It sends an additional security-info message to the responder to signal its choice.  This step is not really necessary because the responder will see the initiator's choice in the first message of the TLS handshake, but it can assist an implementation in setting up its TLS library properly.  Because in this section we assume that the parties already have validated each other's certificates, the security method signalled here is "x509".</t>
      <figure>
        <artwork><![CDATA[
<iq from='romeo@montague.lit/orchard'
    id='hf749j'
    to='juliet@capulet.lit/balcony'
    type='set'>
  <jingle xmlns='urn:xmpp:jingle:1'>
          action='security-info'
          initiator='romeo@montague.lit/orchard'
          sid='a73sjjvkla37jfea'>
    <content creator='initiator' name='xmlstream'>
      <security xmlns='urn:xmpp:jingle:security:xtls:0'>
        <method name='x509'/>
      </security>
    </content>
  </jingle>
</iq>
        ]]></artwork>
      </figure>
      <t>The responder acknowledges receipt by sending an IQ stanza of type "result" (not shown here).</t>
      <t>Parallel to the security-info exchange, the clients negotiate a transport for the Jingle session (here the transport is an in-band bytestream as defined in <xref target='IBB'/>, for which the Jingle negotiation process is specified in <xref target='XEP-0261'/>; however other transports could be used, for example SOCKS5 bytestreams as defined in <xref target='XEP-0065'/> and negotiated for Jingle as specified in <xref target='XEP-0260'/>).  Because the parties wish to establish end-to-end encryption, they do not send application data over the transport until the transport has been secured.  Therefore the first data that they exchange over the transport consists of the standard four-way TLS handshake, encoded in accordance with the negotiated transport method.</t>
      <t><list style='empty'><t>Note: Each transport MUST define a specific time when both clients know that the transport is secured.  When XTLS is not used, the Jingle implementation would signal to the using application that the transport is open when the session-accept is sent or received, or when connectivity checks determine media can flow over one of the transport candidates.  When XTLS is used, the Jingle implementation starts a TLS handshake on the transport and signals to the using application that the transport is open only after the TLS handshake has finished successfully.</t></list></t>
      <t>During the TLS handshake, the responder MUST take the role of the TLS server and the initiator MUST take the role of the TLS client.  Because the transport is an in-band bytestream, the TLS handshake data is prepared as described in <xref target='IBB'/> (i.e., Base64-encoded).  First the initiator (acting as the TLS client) constructs a TLS ClientHello, encodes it according to IBB, and sends it to the responder.</t>
      <figure>
        <artwork><![CDATA[
<iq from='romeo@montague.net/orchard' 
    id='vh38s618'
    to='juliet@capulet.com/balcony'
    type='set'>
  <data xmlns='http://jabber.org/protocol/ibb'
        seq='0'
        sid='vj3hs98y'>
    Base64-encoded-TLS-data
  </data>
</iq>
        ]]></artwork>
      </figure>
      <t>The responder (acting as the TLS server) then acknowledges receipt by sending an IQ stanza of type "result" (not shown here).</t>
      <t>The responder then constructs an appropriate TLS message or messages, such as a ServerHello and a CertificateRequest.</t>
      <t><list style='empty'><t>Note: The responder MUST send a CertificateRequest to the initiator.</t></list></t>
      <figure>
        <artwork><![CDATA[
<iq from='juliet@capulet.com/balcony'
    id='xyw516d0'
    from='romeo@montague.net/orchard' 
    type='set'>
  <data xmlns='http://jabber.org/protocol/ibb' 
        seq='0' 
        sid='vj3hs98y'>
    Base64-encoded-TLS-data
  </data>
</iq>
        ]]></artwork>
      </figure>
      <t>(Because in-band bytestreams are bidirectional and this data is sent from the responder to the initiator, the IBB 'seq' attribute has a value of zero, not 1.)</t>
      <t>The initiator then acknowledges receipt by sending an IQ stanza of type "result" (not shown here).</t>
      <t>After some number of TLS messages, the initiator eventually sends a TLS Finished message to the responder.</t>
      <figure>
        <artwork><![CDATA[
<iq from='romeo@montague.net/orchard' 
    id='s91vd527'
    to='juliet@capulet.com/balcony'
    type='set'>
  <data xmlns='http://jabber.org/protocol/ibb' 
        seq='3' 
        sid='vj3hs98y'>
    Base64-encoded-TLS-data
  </data>
</iq>
        ]]></artwork>
      </figure>
      <t>The responder then acknowledges receipt by sending an IQ stanza of type "result" (not shown here).</t>
      <t>The responder then also sends a TLS Finished message.</t>
      <figure>
        <artwork><![CDATA[
<iq from='juliet@capulet.com/balcony'
    id='z71gs73t'
    from='romeo@montague.net/orchard' 
    type='set'>
  <data xmlns='http://jabber.org/protocol/ibb' 
        seq='3' 
        sid='vj3hs98y'>
    Base64-encoded-TLS-data
  </data>
</iq>
        ]]></artwork>
      </figure>
      <t>The initiator then acknowledges receipt by sending an IQ stanza of type "result" (not shown here).</t>
      <t>If the TLS negotiation has finished successfully, then the Jingle implementation shall signal to the using application that the transport has been secured and is ready to be used.  The parties now have a secure channel for the end-to-end exchange of application data using XMPP as the virtual transport; we call such a channel an XTLS TUNNEL.</t>
    </section>
    <section title='End-to-End Streams over XTLS Protocol Flow' anchor='streamproto'>
      <t>For end-to-end encryption of XMPP stanzas (&lt;message/&gt;, &lt;presence/&gt;, and &lt;iq/&gt;), the application data is an end-to-end XML stream.  After the XTLS tunnel is established, the peers open an XML stream over the tunnel to exchange stanzas.  In this example, the tunnel is established using a transport of IBB, but any streaming transport could be used.</t>
      <t>First the initiator constructs an initial stream header.</t>
      <figure>
        <artwork><![CDATA[
<stream:stream 
        xmlns='jabber:client' 
        xmlns:stream='http://etherx.jabber.org/streams'
        from='romeo@montague.lit/orchard'
        to='juliet@capulet.lit/balcony'
        version='1.0'>
        ]]></artwork>
      </figure>
      <t>Note: In accordance with <xref target='XMPP-CORE'/>, the initial stream header SHOULD include the 'to' and 'from' attributes, which SHOULD specify the full JIDs of the clients. The initiator SHOULD include the version='1.0' flag as shown in the previous example.</t>
      <t>The initiator then transforms the stream header into TLS data, encodes the data into IBB, and sends an IQ-set to the responder.</t>
      <figure>
        <artwork><![CDATA[
<iq from='romeo@montague.net/orchard' 
    id='ur73n153'
    to='juliet@capulet.com/balcony'
    type='set'>
  <data xmlns='http://jabber.org/protocol/ibb' 
        seq='4' 
        sid='vj3hs98y'>
    Base64-TLS-data-of-the-stream-header
  </data>
</iq>
        ]]></artwork>
      </figure>
      <t>The responder then acknowledges receipt by sending an IQ stanza of type "result" (not shown here).</t>
      <t>The responder then constructs a response stream header back to the initiator.</t>
      <figure>
        <artwork><![CDATA[
<stream:stream 
        xmlns='jabber:client' 
        xmlns:stream='http://etherx.jabber.org/streams'
        from='juliet@capulet.lit/balcony'
        id='hs91gh1836d8s717'
        to='romeo@montague.lit/orchard'
        version='1.0'>
        ]]></artwork>
      </figure>
      <t>The responder then sends the response stream header over the XTLS tunnel.</t>
      <figure>
        <artwork><![CDATA[
<iq from='juliet@capulet.com/balcony'
    id='pd61g397'
    to='romeo@montague.net/orchard' 
    type='set'>
  <data xmlns='http://jabber.org/protocol/ibb' 
        seq='4' 
        sid='vj3hs98y'>
    Base64-TLS-data-of-the-responce-stream-header
  </data>
</iq>
        ]]></artwork>
      </figure>
      <t>The initiator then acknowledges receipt by sending an IQ stanza of type "result" (not shown here).</t>
      <t>Once the XML stream is established over the XTLS tunnel, either entity then can send XMPP message, presence, and IQ stanzas, with or without 'to' and 'from' addresses.</t>
      <t>For example, the initiator could construct an XMPP message.</t>
      <figure>
        <artwork><![CDATA[
<message from='romeo@montague.lit/orchard' 
         to='juliet@capulet.lit/balcony'>
  <body>
    M&apos;lady, I would be pleased to make your acquaintance.
  </body>
</message>
        ]]></artwork>
      </figure>
      <t>The initiator then sends the message over the XTLS tunnel.</t>
      <figure>
        <artwork><![CDATA[
<iq from='romeo@montague.net/orchard' 
    id='iq7dh294'
    to='juliet@capulet.com/balcony'
    type='set'>
  <data xmlns='http://jabber.org/protocol/ibb' 
        seq='5' 
        sid='vj3hs98y'>
    Base64-TLS-data
  </data>
</iq>
        ]]></artwork>
      </figure>
      <t>The responder then acknowledges receipt by sending an IQ stanza of type "result" (not shown here).</t>
      <t>The responder could then construct a reply.</t>
      <figure>
        <artwork><![CDATA[
<message from='juliet@capulet.lit/balcony' 
         to='romeo@montague.lit/orchard'>
  <body>Art thou not Romeo, and a Montague?</body>
</message>
        ]]></artwork>
      </figure>
      <t>The responder then sends the reply over the XTLS tunnel.</t>
      <figure>
        <artwork><![CDATA[
<iq from='juliet@capulet.com/balcony'
    id='hr91hd63'
    to='romeo@montague.net/orchard' 
    type='set'>
  <data xmlns='http://jabber.org/protocol/ibb' 
        seq='5' 
        sid='vj3hs98y'>
    Base64-TLS-data
  </data>
</iq>
        ]]></artwork>
      </figure>
      <t>The initiator then acknowledges receipt by sending an IQ stanza of type "result" (not shown here).</t>
      <t>To close the end-to-end XML stream, either party (here the responder) constructs a closing &lt;/stream:stream&gt; element.</t>
      <figure>
        <artwork><![CDATA[
</stream:stream>
        ]]></artwork>
      </figure>
      <t>The client sends the closing element to the peer over the XTLS tunnel.</t>
      <figure>
        <artwork><![CDATA[
<iq from='juliet@capulet.com/balcony'
    id='kr91n475'
    to='romeo@montague.net/orchard' 
    type='set'>
  <data xmlns='http://jabber.org/protocol/ibb' 
        seq='6' 
        sid='vj3hs98y'>
    Base64-TLS-data
  </data>
</iq>
        ]]></artwork>
      </figure>
      <t>The peer then acknowledges receipt by sending an IQ stanza of type "result" (not shown here).</t>
      <t>However, even after the end-to-end XML stream is terminated, the negotiated Jingle transport (here an in-band bytestream) continues and could be re-used. To completely terminate the Jingle session, the terminating party would then also send a Jingle session-terminate message.</t>
      <figure>
        <artwork><![CDATA[
<iq from='juliet@capulet.lit/balcony'
    id='psy617r4'
    to='romeo@montague.lit/orchard'
    type='set'>
  <jingle xmlns='urn:xmpp:jingle:1'
          action='session-terminate'
          initiator='romeo@montague.lit/orchard'
          sid='851ba2'/>
</iq>
        ]]></artwork>
      </figure>
      <t>The other party then acknowledges the Jingle session-terminate by sending an IQ stanza of type "result" (not shown here).</t>
    </section>

    <section title='Bootstrapping Trust on First Communication' anchor='bootstrapping'>
      <t>When two parties first attempt to use XTLS, their certificates might not be accepted (e.g., because they are self-signed or issued by unknown certification authorities).  Therefore each party needs to accept the other's certificate for use in future communication sessions.  There are several ways to do so:</t>
      <t>
        <list style='symbols'>
          <t>Leap of faith.  The recipient can hope that there is no man-in-the-middle during the first communication session.  If the certificate does not change in future sessions, the recipient at least knows that it is talking with the same entity it talked with during the first session.  However, that entity might be a man-in-the-middle rather than the assumed communication partner.  Therefore, leap of faith is discouraged.</t>
          <t>Check fingerprints.  The parties could validate the certificate fingerprints via some trusted means outside the XMPP band, such as in person, via encrypted email, or over the phone.  This is not user-friendly because certificate fingerprints consist of long strings of letters and numbers.  As a result, few humans routinely check certificate fingerprints in protocols such as Secure Shell (ssh).</t>
          <t>One-time password.  The parties can exchange a user-friendly password known only to themselves and verify it out of band before the TLS handshake finishes.  For this purpose, it is REQUIRED for implementations to support at least one TLS cipher that uses Secure Remote Password (SRP) as defined in <xref target='TLS-SRP'/>.</t>
          <t>Channel binding.  It is possible that a future version of this specification will describe how to use an appropriate Simple Authentication and Security Layer (SASL) mechanism, such as <xref target='SCRAM'/>, to authenticate the XTLS tunnel after the TLS handshake finishes; such a method would use the concept of channel bindings as described in <xref target='RFC5056'/>.</t>
        </list>
      </t>
      <t>If the parties use a password or SASL channel binding to bootstrap trust, the process needs to be completed only once.  After the clients have authenticated with the shared secret, they can exchange their certificates for future communication.</t>
      <section title='Exchanging Certificates' anchor='exchange'>
        <t>To retrieve the certificate of the peer for future communications, a client SHOULD request the certificate according to <xref target='XEP-0189'/> over the secure connection.  This works only if XTLS was used to set up an end-to-end secure XML stream; exchanging certificates if XTLS was used for other purposes like file transfer is not possible.  A client MUST NOT request the certificate over the insecure stream-based on the connection to the XMPP server.</t>
        <figure>
          <artwork><![CDATA[
<iq from='romeo@montague.lit/orchard'
    id='hf7634k4'
    to='juliet@capulet.lit/balcony'
    type='get'>
  <pubkeys xmlns='urn:xmpp:pubkey:0'/>
</iq>
          ]]></artwork>
        </figure>
        <t>The peer MUST return its own client certificate.  If the user has different clients with different client certificates and one user certificate, the user certificate SHOULD also be returned.  The user certificate allows it to verify other client certificates using public key retrieval as described in <xref target='XEP-0189'/>.</t>
        <figure>
          <artwork><![CDATA[
<iq from='juliet@capulet.com/balcony'
    id='hf7634k4'
    to='romeo@montague.lit/orchard'
    type='result'>
  <pubkeys xmlns='urn:xmpp:pubkey:0'>
    <keyinfo>
      <x509cert>
MIICCTCCAXKgAwIBAgIJALhU0Id6xxwQMA0GCSqGSIb3DQEBBQUAMA4xDDAKBgNV
BAMTA2ZvbzAeFw0wNzEyMjgyMDA1MTRaFw0wODEyMjcyMDA1MTRaMA4xDDAKBgNV
BAMTA2ZvbzCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA0DPcfeJzKWLGE22p
RMINLKr+CxqozF14DqkXkLUwGzTqYRi49yK6aebZ9ssFspTTjqa2uNpw1U32748t
qU6bpACWHbcC+eZ/hm5KymXBhL3Vjfb/dW0xrtxjI9JRFgrgWAyxndlNZUpN2s3D
hKDfVgpPSx/Zp8d/ubbARxqZZZkCAwEAAaNvMG0wHQYDVR0OBBYEFJWwFqmSRGcx
YXmQfdF+XBWkeML4MD4GA1UdIwQ3MDWAFJWwFqmSRGcxYXmQfdF+XBWkeML4oRKk
EDAOMQwwCgYDVQQDEwNmb2+CCQC4VNCHesccEDAMBgNVHRMEBTADAQH/MA0GCSqG
SIb3DQEBBQUAA4GBAIhlUeGZ0d0msNVxYWAXg2lRsJt9INHJQTCJMmoUeTtaRjyp
ffJtuopguNNBDn+MjrEp2/+zLNMahDYLXaTVmBf6zvY0hzB9Ih0kNTh23Fb5j+yK
QChPXQUo0EGCaODWhfhKRNdseUozfNWOz9iTgMGw8eYNLllQRL//iAOfOr/8
      </x509cert>
    </keyinfo>
  </pubkeys>
</iq>
          ]]></artwork>
        </figure>
      </section>
      <section title='Verification of Non-Human Parties' anchor='bootstrap-bot'>
        <t>If one of the parties is a "bot" (e.g., an automated service or a device such as a set-top box), the password exchange is a bit more complicated.  It is similar to Bluetooth peering if the user has access to both clients at the same time.  One of the following scenarios might apply:</t>
        <t>
          <list style='symbols'>
            <t>The bot can be controlled via a remote control input device.  The human user can enter the same password or "PIN" on both the bot and the XMPP client.</t>
            <t>If the bot has no user input but does have a small display, it could display a random password.  The human user can then enter the provided password on the XMPP client.</t>
            <t>The bot might not have enough buttons for input and might not have an output screen.  In that case the password is fixed.  Similar to Bluetooth peering with simple devices such as a headset, the password will be written in the manual or printed on the device.  For security reasons the device SHOULD NOT use password-based authentication without any user input.  Many Bluetooth devices have at least one button to set the device into peering mode.</t>
            <t>A bot may be associated with a web service and could display a random password when the user has logged in to the web site using HTTPS.  This assumes that an attacker cannot at the same time both control over the web server and perform a man-in-the-middle attack on the XMPP channel.  If the web service knows the GPG key of the user it could send an encrypted email.</t>
          </list>
        </t>
        <t>A user might have different X.509 certificates for each device.  <xref target='XEP-0189'/> can be used to manage the user's certificates.  A client SHOULD check the peer's PubSub node for certificates.  This makes it possible to use the password method only once between two users even if one or both users switch clients.  A user can also communicate with a friend's bots:  they first open a secure link between two chat clients with a password and exchange the user certificates.  After that each device of a user can verify all devices of the other without the need of a password.</t>
        <t>The retrieved certificate from the PubSub node might be signed by a certification authority that the client can verify.  In that case the client MAY skip the password authentication and rely on the X.509 certificate chain.  The client SHOULD ask the user if the certificate is acceptable or if a password exchange is desired.</t>
      </section>
    </section>

    <section title='Session Termination' anchor='terminate'>
      <t>If either client cannot verify the certificate of the peer or receives an invalid message on the TLS layer, it MUST terminate the Jingle session immediately by sending a Jingle session-terminate message that includes a Jingle reason of &lt;security-error/&gt;.</t>
      <figure>
        <artwork><![CDATA[
<iq from='romeo@montague.lit/orchard'
    id='hz81vf48'
    to='juliet@capulet.lit/balcony'
    type='set'>
  <jingle xmlns='urn:xmpp:jingle:1'
          action='session-terminate'
          initiator='romeo@montague.lit/orchard'
          sid='a73sjjvkla37jfea'>
    <reason><security-error/></reason>
  </jingle>
</iq>
        ]]></artwork>
      </figure>
      <t>The other party then acknowledges the session-terminate by sending an IQ stanza of type "result" (not shown here), and the Jingle session is finished.</t>
    </section>

    <section title='Determining Support' anchor='support'>
      <t>If an entity wishes to request the use of XTLS, it SHOULD first determine whether the intended responder supports the protocol.  This can be done directly via <xref target='XEP-0030'/> or indirectly via <xref target='XEP-0115'/>.</t>
      <t>If an entity supports XTLS, it MUST report that by including a service discovery feature of "urn:xmpp:jingle:security:xtls:1" in response to disco#info requests.</t>
      <figure>
        <artwork><![CDATA[
<iq from='romeo@montague.lit/orchard'
    id='disco1'
    to='juliet@capulet.lit/chamber'
    type='get'>
  <query xmlns='http://jabber.org/protocol/disco#info'/>
</iq>
        ]]></artwork>
      </figure>
      <figure>
        <artwork><![CDATA[
<iq from='juliet@capulet.lit/chamber'
    id='disco1'
    to='romeo@montague.lit/orchard'
    type='result'>
  <query xmlns='http://jabber.org/protocol/disco#info'>
    <feature var='urn:xmpp:jingle:security:xtls:1'/>
    <feature var='urn:xmpp:jingle:apps:xmlstream:1'/>
  </query>
</iq>
        ]]></artwork>
      </figure>
      <t>Both service discovery and entity capabilities information could be corrupted or intercepted; for details, see under <xref target='security-dos'/>.</t>
    </section>

    <section title='Security Considerations' anchor='security'>
      <t>This entire document addresses security.  Particular security-related issues are discussed in the following sections.</t>
      <section title='Mandatory-to-Implement Technologies' anchor='security-mti'>
        <t>An implementation MUST at a minimum support the "srp" and "x509" methods.  A future version of this specification will document mandatory-to-implement TLS ciphers.</t>
      </section>
      <section title='Certificates' anchor='security-certs'>
        <t>As noted, XTLS can be used between XMPP clients, between an XMPP client and a remote XMPP service (i.e., a service with which a client does not have a direct XML stream), or between remote XMPP services.  Therefore, a party to an XTLS bytestream will present either a client certificate or a server certificate as appropriate.  Such certificates MUST be generated and validated in accordance with the certificate guidelines guidelines provided in <xref target='XMPP-CORE'/>.</t>
        <t>A future version of this specification might provide additional guidelines regarding certificate validation in the context of client-to-client encryption.</t>
      </section>
      <section title='Denial of Service' anchor='security-dos'>
        <t>Currently XMPP stanzas such as Jingle negotiation messages and service discovery exchanges are not encrypted or signed. As a result, it is possible for an attacker to intercept these stanzas and modify them, thus convincing one party that the other party does not support XTLS and therefore denying the parties an opportunity to use XTLS.</t>
        <t>This is a more general problem with XMPP technologies and needs to be addressed at the core XMPP layer.</t>
      </section>
    </section>

    <section title='IANA Considerations' anchor='iana'>
    <t>It might be helpful to create a registry of TLS methods that can be used in the context of XTLS (e.g., "openpgp" for use of <xref target='RFC5081'/>, "srp" for use of <xref target='TLS-SRP'/>, and "x509" for use of <xref target='TLS'/> with certificates). The registry could be maintained by the IANA or by the XMPP Registrar (see <xref target='XEP-0053'/>). A future version of this specification will provide more detailed information about the registration requirements.</t>
    </section>

  </middle>

  <back>

    <references title="Normative References">

<reference anchor='E2E-REQ'>
<front>
<title>Requirements for End-to-End Encryption in the Extensible Messaging and Presence Protocol (XMPP)</title>
<author initials='P' surname='Saint-Andre' fullname='Peter Saint-Andre'>
    <organization />
</author>
<date month='June' day='29' year='2009' />
<abstract><t>This document describes requirements for end-to-end encryption in the Extensible Messaging and Presence Protocol (XMPP).</t></abstract>
</front>
<seriesInfo name='Internet-Draft' value='draft-saintandre-xmpp-e2e-requirements-01' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-saintandre-xmpp-e2e-requirements-01.txt' />
</reference>

<reference anchor="TERMS">
<front>
<title abbrev='RFC Key Words'>Key words for use in RFCs to Indicate Requirement Levels</title>
<author initials='S.' surname='Bradner' fullname='Scott Bradner'>
<organization>Harvard University</organization>
<address>
<postal>
<street>1350 Mass.  Ave.</street>
<street>Cambridge</street>
<street>MA 02138</street></postal>
<phone>- +1 617 495 3864</phone>
<email>sob@harvard.edu</email></address></author>
<date month='March' year='1997' />
<area>General</area>
<keyword>keyword</keyword>
<abstract>
<t>
   In many standards track documents several words are used to signify
   the requirements in the specification.  These words are often
   capitalized.  This document defines these words as they should be
   interpreted in IETF documents.  Authors who follow these guidelines
   should incorporate this phrase near the beginning of their document:

<list>
<t>
      The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL
      NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;,  &quot;MAY&quot;, and
      &quot;OPTIONAL&quot; in this document are to be interpreted as described in
      RFC 2119.
</t></list></t>
<t>
   Note that the force of these words is modified by the requirement
   level of the document in which they are used.
</t></abstract></front>
<seriesInfo name='BCP' value='14' />
<seriesInfo name='RFC' value='2119' />
<format type='TXT' octets='4723' target='ftp://ftp.isi.edu/in-notes/rfc2119.txt' />
<format type='HTML' octets='14486' target='http://xml.resource.org/public/rfc/html/rfc2119.html' />
<format type='XML' octets='5661' target='http://xml.resource.org/public/rfc/xml/rfc2119.xml' />
</reference>

<reference anchor='TLS'>
<front>
<title>The Transport Layer Security (TLS) Protocol Version 1.2</title>
<author initials='T.' surname='Dierks' fullname='T. Dierks'>
<organization /></author>
<author initials='E.' surname='Rescorla' fullname='E. Rescorla'>
<organization /></author>
<date year='2008' month='August' />
<abstract>
<t>This document specifies Version 1.2 of the Transport Layer Security (TLS) protocol.  The TLS protocol provides communications security over the Internet.  The protocol allows client/server applications to communicate in a way that is designed to prevent eavesdropping, tampering, or message forgery. [STANDARDS TRACK]</t></abstract></front>
<seriesInfo name='RFC' value='5246' />
<format type='TXT' octets='222395' target='ftp://ftp.isi.edu/in-notes/rfc5246.txt' />
</reference>

<reference anchor="IBB">
  <front>
    <title>In-Band Bytestreams (IBB)</title>
    <author initials="J." surname="Karneges" fullname="Justin Karneges">
      <organization/>
      <address>
        <email>justin@affinix.com</email>
      </address>
    </author>
    <date day="17" month="March" year="2009"/>
  </front>
  <seriesInfo name="XSF XEP" value="0047"/>
  <format type="HTML" target="http://www.xmpp.org/extensions/xep-0047.html"/>
</reference>

<reference anchor="JINGLE">
  <front>
    <title>Jingle</title>
    <author initials="S." surname="Ludwig" fullname="Scott Ludwig">
      <organization/>
      <address>
        <email>scottlu@google.com</email>
      </address>
    </author>
    <author initials="J." surname="Beda" fullname="Joe Beda">
      <organization/>
      <address>
        <email>jbeda@google.com</email>
      </address>
    </author>
    <author initials="P." surname="Saint-Andre" fullname="Peter Saint-Andre">
      <organization/>
      <address>
        <email/>
      </address>
    </author>
    <author initials="R." surname="McQueen" fullname="Robert McQueen">
      <organization/>
      <address>
        <email>robert.mcqueen@collabora.co.uk</email>
      </address>
    </author>
    <author initials="S." surname="Egan" fullname="Sean Egan">
      <organization/>
      <address>
        <email>seanegan@google.com</email>
      </address>
    </author>
    <author initials="J." surname="Hildebrand" fullname="Joe Hildebrand">
      <organization/>
      <address>
        <email>jhildebrand@jabber.com</email>
      </address>
    </author>
    <date day="10" month="June" year="2009"/>
  </front>
  <seriesInfo name="XSF XEP" value="0166"/>
  <format type="HTML" target="http://www.xmpp.org/extensions/xep-0166.html"/>
</reference>

<reference anchor="XMPP-CORE">
<front>
<title>Extensible Messaging and Presence Protocol (XMPP): Core</title>
<author initials='P' surname='Saint-Andre' fullname='Peter Saint-Andre'>
    <organization />
</author>
<date month='June' day='1' year='2009' />
<abstract><t>This document defines the core features of the Extensible Messaging and Presence Protocol (XMPP), a technology for streaming Extensible Markup Language (XML) elements for the purpose of exchanging structured information in close to real time between any two or more network-aware entities.  XMPP provides a generalized, extensible framework for incrementally exchanging XML data, upon which a variety of applications can be built.  The framework includes methods for stream setup and teardown, channel encryption, authentication of a client to a server and of one server to another server, and primitives for push-style messages, publication of network availability information ("presence"), and request-response interactions.  This document also specifies the format for XMPP addresses, which are fully internationalizable.</t><t>This document obsoletes RFC 3920.</t></abstract>
</front>
<seriesInfo name='Internet-Draft' value='draft-ietf-xmpp-3920bis-00' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-xmpp-3920bis-00.txt' />
</reference>

    </references>

    <references title="Informative References">

<reference anchor='DTLS'>
<front>
<title>Datagram Transport Layer Security</title>
<author initials='E.' surname='Rescorla' fullname='E. Rescorla'>
<organization /></author>
<author initials='N.' surname='Modadugu' fullname='N. Modadugu'>
<organization /></author>
<date year='2006' month='April' />
<abstract>
<t>This document specifies Version 1.0 of the Datagram Transport Layer Security (DTLS) protocol.  The DTLS protocol provides communications privacy for datagram protocols.  The protocol allows client/server applications to communicate in a way that is designed to prevent eavesdropping, tampering, or message forgery.  The DTLS protocol is based on the Transport Layer Security (TLS) protocol and provides equivalent security guarantees.  Datagram semantics of the underlying transport are preserved by the DTLS protocol. [STANDARDS TRACK]</t></abstract></front>
<seriesInfo name='RFC' value='4347' />
<format type='TXT' octets='56014' target='ftp://ftp.isi.edu/in-notes/rfc4347.txt' />
</reference>

<reference anchor='DTLS-SRTP'>
<front>
<title>Datagram Transport Layer Security (DTLS) Extension to Establish Keys for  Secure Real-time Transport Protocol (SRTP)</title>
<author initials='D' surname='McGrew' fullname='David McGrew'>
    <organization />
</author>
<author initials='E' surname='Rescorla' fullname='Eric Rescorla'>
    <organization />
</author>
<date month='February' day='28' year='2009' />
<abstract><t>This document describes a Datagram Transport Layer Security (DTLS) extension to establish keys for secure RTP (SRTP) and secure RTP Control Protocol (SRTCP) flows.  DTLS keying happens on the media path, independent of any out-of-band signalling channel present.</t></abstract>
</front>
<seriesInfo name='Internet-Draft' value='draft-ietf-avt-dtls-srtp-07' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-avt-dtls-srtp-07.txt' />
</reference>

<reference anchor='HTTP-TLS'>
<front>
<title>HTTP Over TLS</title>
<author initials='E.' surname='Rescorla' fullname='E. Rescorla'>
<organization /></author>
<date year='2000' month='May' />
<abstract>
<t>This memo describes how to use Transport Layer Security (TLS) to secure Hypertext Transfer Protocol (HTTP) connections over the Internet.  This memo provides information for the Internet community.</t></abstract></front>
<seriesInfo name='RFC' value='2818' />
<format type='TXT' octets='15170' target='ftp://ftp.isi.edu/in-notes/rfc2818.txt' />
</reference>

<reference anchor="JINGLE-FILE">
  <front>
    <title>Jingle File Transfer</title>
    <author initials="P." surname="Saint-Andre" fullname="Peter Saint-Andre">
      <organization/>
      <address>
        <email/>
      </address>
    </author>
    <date day="19" month="February" year="2009"/>
  </front>
  <seriesInfo name="XSF XEP" value="0234"/>
  <format type="HTML" target="http://www.xmpp.org/extensions/xep-0234.html"/>
</reference>

<reference anchor="JINGLE-RTP">
  <front>
    <title>Jingle RTP Sessions</title>
    <author initials="S." surname="Ludwig" fullname="Scott Ludwig">
      <organization/>
      <address>
        <email>scottlu@google.com</email>
      </address>
    </author>
    <author initials="P." surname="Saint-Andre" fullname="Peter Saint-Andre">
      <organization/>
      <address>
        <email/>
      </address>
    </author>
    <author initials="S." surname="Egan" fullname="Sean Egan">
      <organization/>
      <address>
        <email>seanegan@google.com</email>
      </address>
    </author>
    <author initials="R." surname="McQueen" fullname="Robert McQueen">
      <organization/>
      <address>
        <email>robert.mcqueen@collabora.co.uk</email>
      </address>
    </author>
    <author initials="D." surname="Cionoiu" fullname="Diana Cionoiu">
      <organization/>
      <address>
        <email>diana@null.ro</email>
      </address>
    </author>
    <date day="10" month="June" year="2009"/>
  </front>
  <seriesInfo name="XSF XEP" value="0167"/>
  <format type="HTML" target="http://www.xmpp.org/extensions/xep-0167.html"/>
</reference>

<reference anchor="MUC">
  <front>
    <title>Multi-User Chat</title>
    <author initials="P." surname="Saint-Andre" fullname="Peter Saint-Andre">
      <organization/>
      <address>
        <email/>
      </address>
    </author>
    <date day="16" month="July" year="2008"/>
  </front>
  <seriesInfo name="XSF XEP" value="0045"/>
  <format type="HTML" target="http://www.xmpp.org/extensions/xep-0045.html"/>
</reference>

<reference anchor='RFC5056'>
<front>
<title>On the Use of Channel Bindings to Secure Channels</title>
<author initials='N.' surname='Williams' fullname='N. Williams'>
<organization /></author>
<date year='2007' month='November' />
<abstract>
<t>The concept of channel binding allows applications to establish that the two end-points of a secure channel at one network layer are the same as at a higher layer by binding authentication at the higher layer to the channel at the lower layer. This allows applications to delegate session protection to lower layers, which has various performance benefits.&lt;/t>&lt;t> This document discusses and formalizes the concept of channel binding to secure channels. [STANDARDS TRACK]</t></abstract></front>
<seriesInfo name='RFC' value='5056' />
<format type='TXT' octets='49995' target='ftp://ftp.isi.edu/in-notes/rfc5056.txt' />
</reference>

<reference anchor='RFC5081'>
<front>
<title>Using OpenPGP Keys for Transport Layer Security (TLS) Authentication</title>
<author initials='N.' surname='Mavrogiannopoulos' fullname='N. Mavrogiannopoulos'>
<organization /></author>
<date year='2007' month='November' />
<abstract>
<t>This memo proposes extensions to the Transport Layer Security (TLS) protocol to support the OpenPGP key format.  The extensions discussed here include a certificate type negotiation mechanism, and the required modifications to the TLS Handshake Protocol.  This memo defines an Experimental Protocol for the Internet community.</t></abstract></front>
<seriesInfo name='RFC' value='5081' />
<format type='TXT' octets='15300' target='ftp://ftp.isi.edu/in-notes/rfc5081.txt' />
</reference>

<reference anchor='TLS-SRP'>
<front>
<title>Using the Secure Remote Password (SRP) Protocol for TLS Authentication</title>
<author initials='D.' surname='Taylor' fullname='D. Taylor'>
<organization /></author>
<author initials='T.' surname='Wu' fullname='T. Wu'>
<organization /></author>
<author initials='N.' surname='Mavrogiannopoulos' fullname='N. Mavrogiannopoulos'>
<organization /></author>
<author initials='T.' surname='Perrin' fullname='T. Perrin'>
<organization /></author>
<date year='2007' month='November' />
<abstract>
<t>This memo presents a technique for using the Secure Remote Password protocol as an authentication method for the Transport Layer Security protocol.  This memo provides information for the Internet community.</t></abstract></front>
<seriesInfo name='RFC' value='5054' />
<format type='TXT' octets='44445' target='ftp://ftp.isi.edu/in-notes/rfc5054.txt' />
</reference>

<reference anchor='SCRAM'>
<front>
<title>Salted Challenge Response (SCRAM) SASL Mechanism</title>
<author initials='A' surname='Menon-Sen' fullname='Abhijit Menon-Sen'>
    <organization />
</author>
<author initials='A' surname='Melnikov' fullname='Alexey  Melnikov'>
    <organization />
</author>
<author initials='C' surname='Newman' fullname='Chris Newman'>
    <organization />
</author>
<author initials='N' surname='Williams' fullname='Nicolas Williams'>
    <organization />
</author>
<date month='May' day='23' year='2009' />
<abstract><t>The secure authentication mechanism most widely deployed and used by Internet application protocols is the transmission of clear-text passwords over a channel protected by Transport Layer Security (TLS). There are some significant security concerns with that mechanism, which could be addressed by the use of a challenge response authentication mechanism protected by TLS.  Unfortunately, the challenge response mechanisms presently on the standards track all fail to meet requirements necessary for widespread deployment, and have had success only in limited use.  This specification describes a family of Simple Authentication and Security Layer (SASL, RFC 4422) authentication mechanisms called the Salted Challenge Response Authentication Mechanism (SCRAM), which addresses the security concerns and meets the deployability requirements.  When used in combination with TLS or an equivalent security layer, a mechanism from this family could improve the status-quo for application protocol authentication and provide a suitable choice for a mandatory-to-implement mechanism for future application protocol standards.</t></abstract>
</front>
<seriesInfo name='Internet-Draft' value='draft-newman-auth-scram-13' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-newman-auth-scram-13.txt' />
</reference>

<reference anchor='X509'>
<front>
<title>Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile</title>
<author initials='D.' surname='Cooper' fullname='D. Cooper'>
<organization /></author>
<author initials='S.' surname='Santesson' fullname='S. Santesson'>
<organization /></author>
<author initials='S.' surname='Farrell' fullname='S. Farrell'>
<organization /></author>
<author initials='S.' surname='Boeyen' fullname='S. Boeyen'>
<organization /></author>
<author initials='R.' surname='Housley' fullname='R. Housley'>
<organization /></author>
<author initials='W.' surname='Polk' fullname='W. Polk'>
<organization /></author>
<date year='2008' month='May' />
<abstract>
<t>This memo profiles the X.509 v3 certificate and X.509 v2 certificate revocation list (CRL) for use in the Internet.  An overview of this approach and model is provided as an introduction.  The X.509 v3 certificate format is described in detail, with additional information regarding the format and semantics of Internet name forms.  Standard certificate extensions are described and two Internet-specific extensions are defined.  A set of required certificate extensions is specified.  The X.509 v2 CRL format is described in detail along with standard and Internet-specific extensions.  An algorithm for X.509 certification path validation is described.  An ASN.1 module and examples are provided in the appendices. [STANDARDS TRACK]</t></abstract></front>
<seriesInfo name='RFC' value='5280' />
<format type='TXT' octets='352580' target='ftp://ftp.isi.edu/in-notes/rfc5280.txt' />
</reference>

<reference anchor="XEP-0030">
  <front>
    <title>Service Discovery</title>
    <author initials="J." surname="Hildebrand" fullname="Joe Hildebrand">
      <organization/>
      <address>
        <email>jhildebrand@jabber.com</email>
      </address>
    </author>
    <author initials="P." surname="Millard" fullname="Peter Millard">
      <organization/>
      <address>
        <email/>
      </address>
    </author>
    <author initials="R." surname="Eatmon" fullname="Ryan Eatmon">
      <organization/>
      <address>
        <email>reatmon@jabber.org</email>
      </address>
    </author>
    <author initials="P." surname="Saint-Andre" fullname="Peter Saint-Andre">
      <organization/>
      <address>
        <email/>
      </address>
    </author>
    <date day="06" month="June" year="2008"/>
  </front>
  <seriesInfo name="XSF XEP" value="0030"/>
  <format type="HTML" target="http://www.xmpp.org/extensions/xep-0030.html"/>
</reference>

<reference anchor="XEP-0053">
  <front>
    <title>XMPP Registrar Function</title>
    <author initials="P." surname="Saint-Andre" fullname="Peter Saint-Andre">
      <organization/>
      <address>
        <email/>
      </address>
    </author>
    <date day="29" month="October" year="2008"/>
  </front>
  <seriesInfo name="XSF XEP" value="0053"/>
  <format type="HTML" target="http://www.xmpp.org/extensions/xep-0053.html"/>
</reference>

<reference anchor="XEP-0065">
  <front>
    <title>SOCKS5 Bytestreams</title>
    <author initials="D." surname="Smith" fullname="Dave Smith">
      <organization/>
      <address>
        <email>dizzyd@jabber.org</email>
      </address>
    </author>
    <author initials="M." surname="Miller" fullname="Matthew Miller">
      <organization/>
      <address>
        <email>linuxwolf@outer-planes.net</email>
      </address>
    </author>
    <author initials="P." surname="Saint-Andre" fullname="Peter Saint-Andre">
      <organization/>
      <address>
        <email/>
      </address>
    </author>
    <date day="21" month="May" year="2007"/>
  </front>
  <seriesInfo name="XSF XEP" value="0065"/>
  <format type="HTML" target="http://www.xmpp.org/extensions/xep-0065.html"/>
</reference>

<reference anchor="XEP-0115">
  <front>
    <title>Entity Capabilities</title>
    <author initials="J." surname="Hildebrand" fullname="Joe Hildebrand">
      <organization/>
      <address>
        <email>jhildebrand@jabber.com</email>
      </address>
    </author>
    <author initials="P." surname="Saint-Andre" fullname="Peter Saint-Andre">
      <organization/>
      <address>
        <email/>
      </address>
    </author>
    <author initials="R." surname="Tron&#xE7;on" fullname="Remko Tron&#xE7;on">
      <organization/>
      <address>
        <email/>
      </address>
    </author>
    <author initials="J." surname="Konieczny" fullname="Jacek Konieczny">
      <organization/>
      <address>
        <email>jajcus@jajcus.net</email>
      </address>
    </author>
    <date day="26" month="February" year="2008"/>
  </front>
  <seriesInfo name="XSF XEP" value="0115"/>
  <format type="HTML" target="http://www.xmpp.org/extensions/xep-0115.html"/>
</reference>

<reference anchor="XEP-0189">
  <front>
    <title>Public Key Publishing</title>
    <author initials="I." surname="Paterson" fullname="Ian Paterson">
      <organization/>
      <address>
        <email>ian.paterson@clientside.co.uk</email>
      </address>
    </author>
    <author initials="P." surname="Saint-Andre" fullname="Peter Saint-Andre">
      <organization/>
      <address>
        <email/>
      </address>
    </author>
    <author initials="D." surname="Meyer" fullname="Dirk Meyer">
      <organization/>
      <address>
        <email>dmeyer@tzi.de</email>
      </address>
    </author>
    <date day="08" month="March" year="2009"/>
  </front>
  <seriesInfo name="XSF XEP" value="0189"/>
  <format type="HTML" target="http://www.xmpp.org/extensions/xep-0189.html"/>
</reference>

<reference anchor="XEP-0260">
  <front>
    <title>Jingle SOCKS5 Bytestreams Transport Method</title>
    <author initials="P." surname="Saint-Andre" fullname="Peter Saint-Andre">
      <organization/>
      <address>
        <email/>
      </address>
    </author>
    <author initials="D." surname="Meyer" fullname="Dirk Meyer">
      <organization/>
      <address>
        <email>dmeyer@tzi.de</email>
      </address>
    </author>
    <date day="19" month="February" year="2009"/>
  </front>
  <seriesInfo name="XSF XEP" value="0260"/>
  <format type="HTML" target="http://www.xmpp.org/extensions/xep-0260.html"/>
</reference>

<reference anchor="XEP-0261">
  <front>
    <title>Jingle In-Band Bytestreams Transport</title>
    <author initials="P." surname="Saint-Andre" fullname="Peter Saint-Andre">
      <organization/>
      <address>
        <email/>
      </address>
    </author>
    <date day="19" month="February" year="2009"/>
  </front>
  <seriesInfo name="XSF XEP" value="0261"/>
  <format type="HTML" target="http://www.xmpp.org/extensions/xep-0261.html"/>
</reference>

    </references>

    <section title='XML Schema' anchor='schema'>
      <t>The XML schema will be provided in a later version of this document.</t>
    </section>

    <section title="Copying Conditions" anchor="copying">
      <t>Regarding this entire document or any portion of it, the authors make no guarantees and are not responsible for any damage resulting from its use.  The authors grant irrevocable permission to anyone to use, modify, and distribute it in any way that does not diminish the rights of anyone else to use, modify, and distribute it, provided that redistributed derivative works do not contain misleading author or version information.  Derivative works need not be licensed under similar terms.</t>
    </section>

  </back>
</rfc>
